<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://blog.bayue.moe/"/>
  <updated>2018-10-11T09:23:22.426Z</updated>
  <id>http://blog.bayue.moe/</id>
  
  <author>
    <name>八月</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>PHP 自动加载</title>
    <link href="http://blog.bayue.moe/2018/10/11/php-autoload/"/>
    <id>http://blog.bayue.moe/2018/10/11/php-autoload/</id>
    <published>2018-10-11T09:22:42.000Z</published>
    <updated>2018-10-11T09:23:22.426Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-自动加载"><a href="#1-自动加载" class="headerlink" title="1. 自动加载"></a>1. 自动加载</h2><p>php的加载文件，一般分为三种情况</p><ol><li>直接<code>include/require</code>，不属于自动加载，一般用于PHP5以前的版本。</li><li>使用<code>__autoload()</code>，PHP5.0引入，在PHP5.1.12之后不再推荐使用。</li><li>使用<code>spl_auoload_register()</code>，现在使用比较多，于PHP5.1.12之后加入，提供了一种更加灵活的方式加载文件。</li></ol><hr><p><strong>具体实例</strong></p><p>第一种没什么说的。主要还是看第二种和第三种。</p><p>假设在一个项目里面有两个文件</p><p><code>Demo.php</code></p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Demo</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment"># coding</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>index.php</code></p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">__autoload</span><span class="params">($class_name)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     $file = dirname(<span class="keyword">__FILE__</span>) . <span class="string">'/'</span> . $class_name;</span><br><span class="line">     <span class="keyword">if</span> (file_exist($file)) &#123;</span><br><span class="line">         <span class="keyword">include</span>($file);</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$obj = <span class="keyword">new</span> Demo();</span><br></pre></td></tr></table></figure><p><code>Demo.php</code>和<code>index.php</code>只要在一个同级目录内，php变会很智能的加载<code>Demo.php</code>,不需要显示的操作。</p><p>但是这里还是存在弊端的，比如一个项目中只能有一个<code>__autoload()</code>，这也意味着自动加载的价值变得很低，于是PHP便在PHP5.1.12版本之后添加了<code>spl_autoload_register()</code>，它接受一个回调函数，使得自动加载更加的灵活。</p><p><code>index.php</code></p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">my_autoload</span><span class="params">($class_name)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    $file = dirname(<span class="keyword">__FILE__</span>) . <span class="string">'/'</span> . $class_name;</span><br><span class="line">    <span class="keyword">if</span> (file_exist($file)) &#123;</span><br><span class="line">        <span class="keyword">include</span>($file);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">spl_autoload_register(<span class="string">'my_autoload'</span>);</span><br><span class="line"></span><br><span class="line">$obj = <span class="keyword">new</span> Demo();</span><br></pre></td></tr></table></figure><p>之前的<code>Demo.php</code>不做修改，将<code>index.php</code>如此修改，便可以同样的功能。</p><p>关于<code>spl_autoload_register()</code>更多的内容可以查看官方文档。</p><p><a href="http://php.net/manual/zh/function.spl-autoload-register.php" target="_blank" rel="noopener">http://php.net/manual/zh/function.spl-autoload-register.php</a></p><h2 id="2-Composer"><a href="#2-Composer" class="headerlink" title="2. Composer"></a>2. Composer</h2><p>在5.3之后，Composer大行其道，号称PHP未来的希望。。。</p><p>使用Composer自动加载时只要引入一个自动加载文件就可以了。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">include_once</span>(<span class="string">'vendor/autoload.php'</span>);</span><br></pre></td></tr></table></figure><p>那么Composer的自动加载时怎么实现的呢，其实也是依靠<code>spl_autoload_register()</code>。</p><p>首先Composer存储三对数组</p><blockquote><p>class=&gt;dir<br>namespace=&gt;array(dir, dir, dir)<br>PSR4=&gt;array(dir, dir1, dir2…)</p></blockquote><p>然后在autoload.php， 存在一个loader，可以触发spl_autoload_register,<br>一旦触发，Composer会对触发的类型进行分析，选择合适的数组，将真实的地址提取出来，然后<code>include</code>，原理还是很简单，推荐大家自行查看一下Composer的自动加载的代码。</p><p>关于composer的一个Tips</p><blockquote><p>在上线代码时可以使用<code>composer dump-autoload -o</code> 转换 <code>PSR-0/4 autoloading</code> 到 <code>classmap</code> 获得更快的载入速度。这特别适用于生产环境，但可能需要一些时间来运行，因此它目前不是默认设置。至于为什么，看完源代码就清晰了。</p></blockquote><h2 id="3-简单实现一个Composer自动加载"><a href="#3-简单实现一个Composer自动加载" class="headerlink" title="3. 简单实现一个Composer自动加载"></a>3. 简单实现一个Composer自动加载</h2><p>简单实现ClassMap的自动加载功能</p><p><a href="https://github.com/bayuexiong/simple-composer/tree/master/vendor" target="_blank" rel="noopener">https://github.com/bayuexiong/simple-composer/tree/master/vendor</a></p><p>使用代码和Composer一样。<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">include</span> <span class="string">'vendor/autoload.php'</span>;</span><br><span class="line"></span><br><span class="line">$obj = <span class="keyword">new</span> Demo(<span class="string">'gg'</span>);</span><br><span class="line">$obj-&gt;sayName();</span><br><span class="line"></span><br><span class="line">$obj2 = <span class="keyword">new</span> Other(<span class="string">'aa'</span>);</span><br><span class="line">$obj2-&gt;sayName();</span><br></pre></td></tr></table></figure></p><h2 id="4-如何选择自动加载机制"><a href="#4-如何选择自动加载机制" class="headerlink" title="4. 如何选择自动加载机制"></a>4. 如何选择自动加载机制</h2><ol><li><p>在程序一开始运行的时候，使用数组，将项目内所有的文件记录下来，实现自动加载(如果使用cache，应该还hold的住)，<code>symfony</code>使用这种形式，代码如下。<br><a href="https://github.com/symfony/class-loader/blob/master/ClassMapGenerator.php" target="_blank" rel="noopener">https://github.com/symfony/class-loader/blob/master/ClassMapGenerator.php</a></p></li><li><p>class名和路径对应，便于查找，但是这样缺乏灵活性，框架的侵入性太强了，代码很受框架的限制，像ThinkPHP，CI就是使用这种形式。</p></li><li><p>组合使用，像Laravel就是使用PSR4和symfony的classLoader。</p></li></ol><h2 id="5-CI框架的自动加载"><a href="#5-CI框架的自动加载" class="headerlink" title="5. CI框架的自动加载"></a>5. CI框架的自动加载</h2><p>现在公司使用CI框架的情况比较多，所以对CI框架的自动加载做一些详细的介绍。</p><p>对于一个普通的CI加载类的方式：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">$this</span>-&gt;load-&gt;library(<span class="string">'myclass'</span>);</span><br></pre></td></tr></table></figure><p>CI框架的内部是如何运行的呢？首先上个流程图</p><p>其实CI框架的自动加载并没有借助spl系列的函数，这可能与CI框架诞生的年岁有关，在那个时期不失为一种优秀的自动加载方法。</p><p>但是现在来说，算不上优秀，其对命名的规范太过苛刻了，效率也谈不上高效，当然CI框架的整体速度还是很快的，毕竟像<code>symfony</code>之流的框架为了实现完成解耦，付出了很多性能上的代价。</p><p><strong>Tips</strong></p><blockquote><p>对于一个普通的加载类<br><code>$this-&gt;load-&gt;library($library, $param, $object_name);</code></p><ol><li><code>$library</code> 可以是一个数组key代表需要加载的类，value则是obejct_name。</li><li><code>$param</code> 需要一个数组，作于传入构造器中的值</li><li><code>$object_name</code> 和<code>$this-&gt;load-&gt;model(calss, object_name)</code>中第二个参数一样，加载完之后可以<code>$this-&gt;object_name-&gt;sayHello()</code></li></ol></blockquote><p>具体的可以结合CI的文档再加上阅读CI的源代码，的确CI的文档相比其他的框架比较全面，但是一些技巧也没有详尽的介绍。</p><h2 id="6-小结"><a href="#6-小结" class="headerlink" title="6. 小结"></a>6. 小结</h2><p>使用Composer吧！使用RSP4命名空间规范吧！这样各个组件与组件之间，自己的代码和别人的代码都可以无痛的结合，不需要花费额外的精力去处理文件加载的问题。</p><h2 id="7-补充"><a href="#7-补充" class="headerlink" title="7. 补充"></a>7. 补充</h2><ol><li><a href="http://php.net/manual/zh/language.namespaces.php" target="_blank" rel="noopener">命名空间</a>，命名空间提供了一种灵活的效率更高的辅助自动加载的方法。</li><li><a href="https://segmentfault.com/a/1190000002521658" target="_blank" rel="noopener">PSR4</a> 规范命名空间的定义，是最近比较流行的命名空间规范。</li></ol><hr><p>材料参考:</p><ol><li><a href="https://github.com/qinjx/adv_php_book/blob/master/class_autoload.md" target="_blank" rel="noopener">https://github.com/qinjx/adv_php_book/blob/master/class_autoload.md</a></li><li><a href="http://php.net/manual/zh/function.spl-autoload-register.php" target="_blank" rel="noopener">spl_autoload_register</a></li><li><a href="http://php.net/manual/zh/function.autoload.php" target="_blank" rel="noopener">__atuoload</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1-自动加载&quot;&gt;&lt;a href=&quot;#1-自动加载&quot; class=&quot;headerlink&quot; title=&quot;1. 自动加载&quot;&gt;&lt;/a&gt;1. 自动加载&lt;/h2&gt;&lt;p&gt;php的加载文件，一般分为三种情况&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;直接&lt;code&gt;include/requi
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>PHP 图片上传关于exif</title>
    <link href="http://blog.bayue.moe/2018/09/13/php-image-exif/"/>
    <id>http://blog.bayue.moe/2018/09/13/php-image-exif/</id>
    <published>2018-09-12T17:39:12.000Z</published>
    <updated>2018-09-27T06:27:46.574Z</updated>
    
    <content type="html"><![CDATA[<h1 id="获取图片的exif"><a href="#获取图片的exif" class="headerlink" title="获取图片的exif"></a>获取图片的exif</h1><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$exif = exif_read_data($path, <span class="string">'IFD0'</span>);</span><br></pre></td></tr></table></figure><h2 id="图片颠倒"><a href="#图片颠倒" class="headerlink" title="图片颠倒"></a>图片颠倒</h2><p>用手机拍摄时有可能会导致图像旋转，所以我们要根据exif里的值，进行图片旋转</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这里使用intervention/image操作图片</span></span><br><span class="line">$img = Image::make($file_path);</span><br><span class="line">$exif = $img-&gt;exif();</span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span> (<span class="keyword">isset</span>($exif[<span class="string">'Orientation'</span>]) &amp;&amp; $exif[<span class="string">'Orientation'</span>]) &#123;</span><br><span class="line">        <span class="keyword">switch</span> ($exif[<span class="string">'Orientation'</span>]) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">                $img-&gt;rotate(<span class="number">180</span>)-&gt;save();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">                $img-&gt;rotate(<span class="number">-90</span>)-&gt;save(); <span class="comment">// 逆时针转90度</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">8</span>:</span><br><span class="line">                $img-&gt;rotate(<span class="number">90</span>)-&gt;save(); <span class="comment">// 顺时针转90度</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><blockquote><p>在使用<code>intervention/image</code>进行图片存储的时候，出现Orientation被置为0(unknow)的情况，可以先用<code>file_put_contents</code>来存储图片，再使用<code>intervention/image</code>进行图片编辑</p></blockquote><h3 id="视频缩略图颠倒"><a href="#视频缩略图颠倒" class="headerlink" title="视频缩略图颠倒"></a>视频缩略图颠倒</h3><p>顺便也提一下这个问题，这个和图片颠倒是一个问题，手机在竖屏拍摄的时候实际上是用了一个参数旋转了视频</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$out = [];</span><br><span class="line"><span class="comment">// 这里的2&gt;&amp;1不可以缺少，不然是直接输出，而不是赋值到out</span></span><br><span class="line">exec(<span class="string">"ffmpeg -i &#123;$file&#125; 2&gt;&amp;1"</span>, $out);</span><br><span class="line">$ret = implode(<span class="string">''</span>, $out);</span><br><span class="line"><span class="comment">// 判断rotation 是否存在</span></span><br><span class="line"><span class="keyword">if</span> (strpos($ret, <span class="string">'rotation of -90.00 degrees'</span>) !== <span class="keyword">false</span>) &#123;</span><br><span class="line">    exec(<span class="string">"ffmpeg -i &#123;$file&#125; -y -t 0.001 -vf \"transpose=1\"  &#123;$cover&#125;"</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    exec(<span class="string">"ffmpeg -i &#123;$file&#125; -y  -t 0.001 &#123;$cover&#125;"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;获取图片的exif&quot;&gt;&lt;a href=&quot;#获取图片的exif&quot; class=&quot;headerlink&quot; title=&quot;获取图片的exif&quot;&gt;&lt;/a&gt;获取图片的exif&lt;/h1&gt;&lt;figure class=&quot;highlight php&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td 
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>PHP 闭包</title>
    <link href="http://blog.bayue.moe/2018/09/13/php-clourse/"/>
    <id>http://blog.bayue.moe/2018/09/13/php-clourse/</id>
    <published>2018-09-12T16:49:00.000Z</published>
    <updated>2018-09-27T06:25:42.552Z</updated>
    
    <content type="html"><![CDATA[<h1 id="闭包的介绍"><a href="#闭包的介绍" class="headerlink" title="闭包的介绍"></a>闭包的介绍</h1><p>闭包是词法作用域的体现，一般编程语言有这些特性</p><ol><li>函数是一阶值（First-class value），即函数可以作为另一个函数的返回值或参数，还可以作为一个变量的值。</li><li>函数可以嵌套定义，即在一个函数内部可以定义另一个函数。</li></ol><p>三个关键点</p><ol><li>函数</li><li>自由变量</li><li>作用域</li></ol><h2 id="自由变量"><a href="#自由变量" class="headerlink" title="自由变量"></a>自由变量</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">1</span></span><br><span class="line"><span class="keyword">let</span> b = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(a)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子里函数b因为捕获了外部作用域（环境）中的变量a，因此形成了闭包。 而由于变量a并不属于函数b，所以在概念里被称之为「自由变量」。</p><p>注意点：</p><ol><li>在一些语言里，「捕获」这一行为还有一个特点：闭包只会捕获自由变量的引用。</li><li>在PHP中，需要使用<code>use</code>关键词显示调用自由变量</li></ol><h2 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h2><p>可以使用外部的「自由变量」，内部变量不能被访问，形成一个相对安全的访问环境</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li>记住定义当时的外部环境</li><li>封闭外部环境</li><li>延迟执行</li></ol><h1 id="普通函数和闭包函数"><a href="#普通函数和闭包函数" class="headerlink" title="普通函数和闭包函数"></a>普通函数和闭包函数</h1><h2 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h2><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$func = <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">$func();</span><br><span class="line"></span><br><span class="line">$a = <span class="string">'1'</span>;</span><br><span class="line">$func = <span class="function"><span class="keyword">function</span> <span class="params">()</span> <span class="title">use</span> <span class="params">($a)</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$func();</span><br></pre></td></tr></table></figure><h2 id="作用域-1"><a href="#作用域-1" class="headerlink" title="作用域"></a>作用域</h2><ol><li>闭包拥有独立的作用域，基本等同普通函数</li><li>在方法中使用时，等同于实例的方法，可以直接使用$this（&gt;=5.4）</li></ol><h2 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h2><h3 id="this-的使用"><a href="#this-的使用" class="headerlink" title="$this 的使用"></a>$this 的使用</h3><p>在一次开发中遇到关于闭包的一个问题</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Demo</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        $data = <span class="keyword">$this</span>-&gt;isCache(<span class="string">'name'</span>, <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">$this</span>-&gt;sayHello();</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="function"><span class="keyword">function</span> <span class="title">sayHello</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">'Hello, World'</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> $name</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> $callback</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> array</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">isCache</span><span class="params">($name, $callback)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        $callback();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">array</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我希望在一个闭包中调用这个类的一个受保护的方法（这里假设是sayHello）,结果在运行的时候，直接出现了语法级别的报错。</p><p>查了一些资料发现了问题</p><ol><li>5.3 版本不能直接在闭包中使用$this</li></ol><p>PHP的bug，在5.4中得以修复</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$that = <span class="keyword">$this</span>;</span><br><span class="line">data = <span class="keyword">$this</span>-&gt;isCache(<span class="string">'name'</span>, <span class="function"><span class="keyword">function</span> <span class="params">()</span> <span class="title">use</span> <span class="params">($that)</span> </span>&#123;</span><br><span class="line">    $that-&gt;sayHello(); <span class="comment">// 这里只能是public</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>看似这个问题解决了，不过在stackoverflow上一位热心人士的提醒中，这样是会出现一些问题的，因为这样传递$this, 是<strong>赋值传递</strong>，也就是说，在闭包中调用方法导致实例属性的变化不会反应到闭包外面，这样在一些特殊情况，会导致闭包内外属性不一致，所以这里最好使用<strong>引用传递</strong>，<strong>除非你知道你在干什么！</strong></p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$that = <span class="keyword">$this</span>;</span><br><span class="line">data = <span class="keyword">$this</span>-&gt;isCache(<span class="string">'name'</span>, <span class="function"><span class="keyword">function</span> <span class="params">()</span> <span class="title">use</span> <span class="params">(&amp;$that)</span> </span>&#123;</span><br><span class="line">    $that-&gt;sayHello(); <span class="comment">// 这里只能是public</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>如果在5.4版本下，不但可以直接使用$this，而且作用域等同于实例中的方法</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$data = <span class="keyword">$this</span>-&gt;isCache(<span class="string">'name'</span>, <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    $that-&gt;sayHello(); <span class="comment">// 这里可以是任意限制符</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="Closure类"><a href="#Closure类" class="headerlink" title="Closure类"></a>Closure类</h2><ul><li><a href="https://php.net/manual/en/closure.construct.php" target="_blank" rel="noopener">Closure::__construct</a> — Constructor that disallows instantiation</li><li><a href="https://php.net/manual/en/closure.bind.php" target="_blank" rel="noopener">Closure::bind</a> — 复制一个闭包，绑定指定的$this对象和类作用域。</li><li><a href="https://php.net/manual/en/closure.bindto.php" target="_blank" rel="noopener">Closure::bindTo</a> — 复制当前闭包对象，绑定指定的$this对象和类作用域。</li><li><a href="https://php.net/manual/en/closure.call.php" target="_blank" rel="noopener">Closure::call</a> — 绑定指定的$this对象和类作用域并执行</li><li><a href="https://php.net/manual/en/closure.fromcallable.php" target="_blank" rel="noopener">Closure::fromCallable</a> — 将一个可执行函数转换为闭包函数</li></ul><h3 id="bind和bindTo的区别"><a href="#bind和bindTo的区别" class="headerlink" title="bind和bindTo的区别"></a>bind和bindTo的区别</h3><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// bind，相当把一个类的加上加上一个方法，并且将该方法转换成闭包</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> $sfoo = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">private</span> $ifoo = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line">$cl1 = <span class="keyword">static</span> <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> A::$sfoo;</span><br><span class="line">&#125;;</span><br><span class="line">$cl2 = <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;ifoo;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">$bcl1 = Closure::bind($cl1, <span class="keyword">null</span>, <span class="string">'A'</span>);</span><br><span class="line">$bcl2 = Closure::bind($cl2, <span class="keyword">new</span> A(), <span class="string">'A'</span>);</span><br><span class="line"><span class="keyword">echo</span> $bcl1(), <span class="string">"\n"</span>; <span class="comment">// 1</span></span><br><span class="line"><span class="keyword">echo</span> $bcl2(), <span class="string">"\n"</span>;<span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// bindTo,改变指定的$this对象和类作用域</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">__construct</span><span class="params">($val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;val = $val;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">getClosure</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//returns closure bound to this object and scope</span></span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;val; &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$ob1 = <span class="keyword">new</span> A(<span class="number">1</span>);</span><br><span class="line">$ob2 = <span class="keyword">new</span> A(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">$cl = $ob1-&gt;getClosure();</span><br><span class="line"><span class="keyword">echo</span> $cl(), <span class="string">"\n"</span>;</span><br><span class="line">$cl = $cl-&gt;bindTo($ob2);</span><br><span class="line"><span class="keyword">echo</span> $cl(), <span class="string">"\n"</span>;</span><br></pre></td></tr></table></figure><p>虽然两者看上去像，实际上不是一回事😓。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;闭包的介绍&quot;&gt;&lt;a href=&quot;#闭包的介绍&quot; class=&quot;headerlink&quot; title=&quot;闭包的介绍&quot;&gt;&lt;/a&gt;闭包的介绍&lt;/h1&gt;&lt;p&gt;闭包是词法作用域的体现，一般编程语言有这些特性&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;函数是一阶值（First-class va
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>PHP 命名空间</title>
    <link href="http://blog.bayue.moe/2018/09/13/namespace/"/>
    <id>http://blog.bayue.moe/2018/09/13/namespace/</id>
    <published>2018-09-12T16:42:48.000Z</published>
    <updated>2018-09-27T06:17:40.398Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-为什么需要命名空间"><a href="#1-为什么需要命名空间" class="headerlink" title="1. 为什么需要命名空间"></a>1. 为什么需要命名空间</h2><ol><li>用户编写的代码与PHP内部的类/函数/常量或第三方类/函数/常量之间的名字冲突。</li><li>为很长的标识符名称(通常是为了缓解第一类问题而定义的)创建一个别名（或简短）的名称，提高源代码的可读性。</li></ol><h2 id="2-什么受作用于命名空间"><a href="#2-什么受作用于命名空间" class="headerlink" title="2. 什么受作用于命名空间"></a>2. 什么受作用于命名空间</h2><ul><li>类</li><li>接口</li><li>函数</li><li>常量</li></ul><h2 id="3-定义命名空间"><a href="#3-定义命名空间" class="headerlink" title="3. 定义命名空间"></a>3. 定义命名空间</h2><p>命名空间必须在所有的其他代码之前，一个以外：declare关键字。</p><p>还有注意点是：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里是允许有空行的</span></span><br><span class="line">    <span class="keyword">namespace</span> <span class="title">my</span>;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Demo</span></span></span><br><span class="line"><span class="class">    </span>&#123;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这里不能有空行，<span class="meta">&lt;?php</span>必须位于文件的第一行</span></span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">namespace</span> <span class="title">my</span>;</span><br></pre></td></tr></table></figure><p>还需要注意的是，在使用define的使用，key值需要加入命名空间</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">    <span class="keyword">namespace</span> <span class="title">my</span>;</span><br><span class="line">    define(<span class="string">'my\A'</span>,<span class="number">1</span>);</span><br><span class="line">    define(<span class="keyword">__NAMESPACE__</span> . <span class="string">'\B'</span>,<span class="number">1</span>); \\推荐</span><br></pre></td></tr></table></figure><h2 id="4-使用命名空间"><a href="#4-使用命名空间" class="headerlink" title="4. 使用命名空间"></a>4. 使用命名空间</h2><p>命名空间有三种引用方式</p><ol><li>非限定名称</li><li>限定名称</li><li>完全名称</li></ol><p>file1.php</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">Foo</span>\<span class="title">Bar</span>\<span class="title">subnamespace</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> FOO = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">foo</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="keyword">function</span> <span class="title">staticmethod</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>file2.php</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">Foo</span>\<span class="title">Bar</span>;</span><br><span class="line"><span class="keyword">include</span> <span class="string">'file1.php'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> FOO = <span class="number">2</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">foo</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="keyword">function</span> <span class="title">staticmethod</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 非限定名称 */</span></span><br><span class="line">foo(); </span><br><span class="line"><span class="comment">// 解析为 Foo\Bar\foo resolves to function Foo\Bar\foo</span></span><br><span class="line"></span><br><span class="line">foo::staticmethod(); </span><br><span class="line"><span class="comment">// 解析为类 Foo\Bar\foo的静态方法staticmethod。resolves to </span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span>\<span class="title">Bar</span>\<span class="title">foo</span>, <span class="title">method</span> <span class="title">staticmethod</span></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">echo</span> <span class="title">FOO</span>; // <span class="title">resolves</span> <span class="title">to</span> <span class="title">constant</span> <span class="title">Foo</span>\<span class="title">Bar</span>\<span class="title">FOO</span></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">/* 限定名称 */</span></span><br><span class="line">subnamespace\foo(); </span><br><span class="line"><span class="comment">// 解析为函数 Foo\Bar\subnamespace\foo</span></span><br><span class="line"></span><br><span class="line">subnamespace\foo::staticmethod(); </span><br><span class="line"><span class="comment">// 解析为类 Foo\Bar\subnamespace\foo, 以及类的方法 staticmethod</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">echo</span> subnamespace\FOO; <span class="comment">// 解析为常量 Foo\Bar\subnamespace\FOO</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 完全限定名称 */</span></span><br><span class="line">\Foo\Bar\foo(); <span class="comment">// 解析为函数 Foo\Bar\foo</span></span><br><span class="line"></span><br><span class="line">\Foo\Bar\foo::staticmethod(); <span class="comment">// 解析为类 Foo\Bar\foo, 以及类的方法 staticmethod</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">echo</span> \Foo\Bar\FOO; <span class="comment">// 解析为常量 Foo\Bar\FOO</span></span><br><span class="line"></span><br><span class="line">$a = \strlen(<span class="string">'h1'</span>); <span class="comment">//调用全局函数</span></span><br></pre></td></tr></table></figure><p>一般我们只使用完全限定或者非限定的使用方式，限定名称类似于Python中的<code>import *</code>，如果你要使用同一个包中的很多类，又不行在文件开头出现大量的<code>use</code>，可以使用限定名称,不过非常不推荐，最佳实践是用了什么就引入什么，而不是直接引入包。</p><h2 id="4-别名和导入"><a href="#4-别名和导入" class="headerlink" title="4. 别名和导入"></a>4. 别名和导入</h2><p>版本支持</p><ol><li>所有支持命名空间的版本都可以三种别名和导入的方式：类，接口，命名空间。</li><li>PHP5.6之后支持了函数和常量</li></ol><p>注意点</p><ol><li>必须是完全限定名称。</li><li>完全限定名称前的<code>\</code>可以省略，也推荐省略。</li></ol><p>例子<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> <span class="title">com</span>\<span class="title">wy</span>\<span class="title">Hello</span>;</span><br><span class="line"><span class="comment">// use \com\wy\Hello; 也可以，不过意义不大</span></span><br><span class="line"></span><br><span class="line">$h = <span class="keyword">new</span> Hello();</span><br></pre></td></tr></table></figure></p><h2 id="5-全局命名空间"><a href="#5-全局命名空间" class="headerlink" title="5. 全局命名空间"></a>5. 全局命名空间</h2><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">$foo = <span class="keyword">new</span> \Foo();</span><br></pre></td></tr></table></figure><p>​    注意点</p><p>​    1. 系统函数可以不使用全局命名空间</p><p>​    2. 如果系统函数被复写，那么就需要全局命名空间</p><h2 id="6-PSR-4-Autoload-自动加载"><a href="#6-PSR-4-Autoload-自动加载" class="headerlink" title="6. PSR-4 Autoload 自动加载"></a>6. PSR-4 Autoload 自动加载</h2><p><a href="https://segmentfault.com/a/1190000002521658" target="_blank" rel="noopener">PSR-4规范</a></p><p>例子</p><table><thead><tr><th style="text-align:left">完整类名</th><th style="text-align:left">命名空间前缀</th><th style="text-align:left">文件基目录</th><th style="text-align:left">文件路径</th></tr></thead><tbody><tr><td style="text-align:left">\Symfony\Core\Request</td><td style="text-align:left">Symfony\Core</td><td style="text-align:left">./vendor/Symfony/Core/</td><td style="text-align:left">./vendor/Symfony/Core/Request.php</td></tr></tbody></table><h2 id="7-PSR-0-和-PSR-4"><a href="#7-PSR-0-和-PSR-4" class="headerlink" title="7. PSR-0 和 PSR-4"></a>7. PSR-0 和 PSR-4</h2><p><a href="https://segmentfault.com/a/1190000002616752" target="_blank" rel="noopener">PSR-0 和 PSR-4 的区别</a></p><p>1.在composer中定义的NS，psr4必须以\结尾否则会抛出异常，psr0则不要求</p><p>2.psr0里面最后一个\之后的类名中，如果有下划线，则会转换成路径分隔符，如Name_Space_Test会转换成Name\Space\Test.php。在psr4中下划线不存在实际意义</p><p>3.psr0有更深的目录结构，比如定义了NS为 <code>Foo\Bar =&gt; vendor\foo\bar\src</code>，<br><code>use Foo\Bar\Tool\Request</code>调用NS。<br>如果以psr0方式加载，实际的目录为<code>vendor\foo\bar\src\Foo\Bar\Tool\Request.php</code><br>如果以psr4方式加载，实际目录为<code>vendor\foo\bar\src\Tool\Request.php</code></p><h2 id="8-效率"><a href="#8-效率" class="headerlink" title="8. 效率"></a>8. 效率</h2><p>PSR-0和PSR-4的运行效率是相似的，但是都不如classmap的运行效率，因为Composer中，classmap是在array中直接查找的，而PSR-0和PSR-4都需要迭代一个数组，所以我们都使用classmap？，这也不对，因为classmap只是对应一个文件夹，对于其子文件夹是无力的，所以在开发时使用PSR-4，在发布正式版时使用classmap。</p><p>composer中转换classmap的指令</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">composer dump-autoload -o</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1-为什么需要命名空间&quot;&gt;&lt;a href=&quot;#1-为什么需要命名空间&quot; class=&quot;headerlink&quot; title=&quot;1. 为什么需要命名空间&quot;&gt;&lt;/a&gt;1. 为什么需要命名空间&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;用户编写的代码与PHP内部的类/函数/常量或第三方类
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Lumen 生命周期</title>
    <link href="http://blog.bayue.moe/2018/09/12/lumen-life-cycle/"/>
    <id>http://blog.bayue.moe/2018/09/12/lumen-life-cycle/</id>
    <published>2018-09-12T10:15:30.184Z</published>
    <updated>2018-09-19T15:31:30.585Z</updated>
    
    <content type="html"><![CDATA[<h2 id="入口文件"><a href="#入口文件" class="headerlink" title="入口文件"></a>入口文件</h2><p>一般在<code>public</code>下面的<code>index.php</code>，当然你可以自定义文件，甚至目录。</p><p>首先来看一下<code>index.php</code>的结构</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">define(<span class="string">'APP_PATH'</span>, dirname(<span class="keyword">__DIR__</span>));</span><br><span class="line"></span><br><span class="line">$app = <span class="keyword">require</span> APP_PATH . <span class="string">'/bootstrap/app.php'</span>; <span class="comment">// 创建实例</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">$app-&gt;run(); <span class="comment">// 请求并响应</span></span><br></pre></td></tr></table></figure><h2 id="创建-Lumen-实例"><a href="#创建-Lumen-实例" class="headerlink" title="创建 Lumen 实例"></a>创建 Lumen 实例</h2><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">$app = <span class="keyword">new</span> Laravel\Lumen\Application(</span><br><span class="line">    realpath(<span class="keyword">__DIR__</span> . <span class="string">'/../'</span>) <span class="comment">// 这边如果你改变了入口文件的目录，需要使用绝对路径</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Application 初始化</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span><span class="params">($basePath = null)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (! <span class="keyword">empty</span>(env(<span class="string">'APP_TIMEZONE'</span>))) &#123;</span><br><span class="line">        date_default_timezone_set(env(<span class="string">'APP_TIMEZONE'</span>, <span class="string">'UTC'</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">$this</span>-&gt;basePath = $basePath;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 引导容器，注册基础服务提供者</span></span><br><span class="line">    <span class="keyword">$this</span>-&gt;bootstrapContainer();</span><br><span class="line">    <span class="comment">// 重定义异常、错误处理</span></span><br><span class="line">    <span class="keyword">$this</span>-&gt;registerErrorHandling();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>「创建 Lumen 应用实例」这个阶段它做了很多的基础工作, 除了上面提到的，包括但不限于：创建 APP 容器、注册应用路径、注册基础服务提供者、配置中间件和引导程序等。</p><blockquote><p>什么是服务提供者，简单来说如果我们需要一个服务，<code>记日志</code>，在程序里面标志为<code>log</code>，那么给这个服务提供实现，为了规范这个服务的实现，我们需要提供一个<code>契约（contract）</code>，和每个服务提供者达成<code>契约</code>，这个更换服务提供者也不会影响其他服务的运行。</p></blockquote><h2 id="请求并响应"><a href="#请求并响应" class="headerlink" title="请求并响应"></a>请求并响应</h2><p>Lumen的解析请求和响应都在入口文件中<code>$app-&gt;run()</code>里面进行，大致分下面4个步骤：</p><ol><li>加载前置中间件</li><li>匹配路由</li><li>返回接口</li><li>加载后置中间件</li></ol><p>主要实现代码都在<code>vendor/laravel/lumen-framework/src/Concerns/RoutesRequests.php</code></p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Run the application and send the response.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>  SymfonyRequest|null  $request</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> void</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">run</span><span class="params">($request = null)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 加载前置路由器，处理请求并响应</span></span><br><span class="line">    $response = <span class="keyword">$this</span>-&gt;dispatch($request);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回响应</span></span><br><span class="line">    <span class="keyword">if</span> ($response <span class="keyword">instanceof</span> SymfonyResponse) &#123;</span><br><span class="line">        $response-&gt;send(); </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">echo</span> (string) $response;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 执行后置中间件</span></span><br><span class="line">    <span class="keyword">if</span> (count(<span class="keyword">$this</span>-&gt;middleware) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;callTerminableMiddleware($response);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Dispatch the incoming request.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>  SymfonyRequest|null  $request</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> Response</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">dispatch</span><span class="params">($request = null)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 解析请求method &amp; path</span></span><br><span class="line">    <span class="keyword">list</span>($method, $pathInfo) = <span class="keyword">$this</span>-&gt;parseIncomingRequest($request);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 加载前置中间件，匹配路由</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;sendThroughPipeline(<span class="keyword">$this</span>-&gt;middleware, <span class="function"><span class="keyword">function</span> <span class="params">()</span> <span class="title">use</span> <span class="params">($method, $pathInfo)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 直接匹配路由</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">isset</span>(<span class="keyword">$this</span>-&gt;routes[$method.$pathInfo])) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;handleFoundRoute([<span class="keyword">true</span>, <span class="keyword">$this</span>-&gt;routes[$method.$pathInfo][<span class="string">'action'</span>], []]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// FastRoute 匹配动态路由</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;handleDispatcherResponse(</span><br><span class="line">                <span class="keyword">$this</span>-&gt;createDispatcher()-&gt;dispatch($method, $pathInfo)</span><br><span class="line">            );</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (<span class="keyword">Exception</span> $e) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;prepareResponse(<span class="keyword">$this</span>-&gt;sendExceptionToHandler($e));</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable $e) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;prepareResponse(<span class="keyword">$this</span>-&gt;sendExceptionToHandler($e));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;入口文件&quot;&gt;&lt;a href=&quot;#入口文件&quot; class=&quot;headerlink&quot; title=&quot;入口文件&quot;&gt;&lt;/a&gt;入口文件&lt;/h2&gt;&lt;p&gt;一般在&lt;code&gt;public&lt;/code&gt;下面的&lt;code&gt;index.php&lt;/code&gt;，当然你可以自定义文件，甚至目
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>PHP 数组的使用拾遗</title>
    <link href="http://blog.bayue.moe/2018/08/31/php-array/"/>
    <id>http://blog.bayue.moe/2018/08/31/php-array/</id>
    <published>2018-08-31T08:27:08.093Z</published>
    <updated>2019-04-12T02:06:14.564Z</updated>
    
    <content type="html"><![CDATA[<p>收集了一些php原始数组函数的使用、注意事项</p><h2 id="和-array-merge"><a href="#和-array-merge" class="headerlink" title="+ 和 array_merge"></a>+ 和 array_merge</h2><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; $a = [<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>];</span><br><span class="line">=&gt; [</span><br><span class="line">     <span class="number">2</span>,</span><br><span class="line">     <span class="number">3</span>,</span><br><span class="line">     <span class="number">4</span>,</span><br><span class="line">   ]</span><br><span class="line">&gt;&gt;&gt; $b = [<span class="number">2</span>,<span class="number">5</span>,<span class="number">6</span>];</span><br><span class="line">=&gt; [</span><br><span class="line">     <span class="number">2</span>,</span><br><span class="line">     <span class="number">5</span>,</span><br><span class="line">     <span class="number">6</span>,</span><br><span class="line">   ]</span><br><span class="line">&gt;&gt;&gt; $a + $b;</span><br><span class="line">=&gt; [</span><br><span class="line">     <span class="number">2</span>,</span><br><span class="line">     <span class="number">3</span>,</span><br><span class="line">     <span class="number">4</span>,</span><br><span class="line">   ]</span><br><span class="line">&gt;&gt;&gt; array_merge($a, $b);</span><br><span class="line">=&gt; [</span><br><span class="line">     <span class="number">2</span>,</span><br><span class="line">     <span class="number">3</span>,</span><br><span class="line">     <span class="number">4</span>,</span><br><span class="line">     <span class="number">2</span>,</span><br><span class="line">     <span class="number">5</span>,</span><br><span class="line">     <span class="number">6</span>,</span><br><span class="line">   ]</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure><p>有时候会混淆两种的区别，这两个操作其实有很多不同，<code>+</code>实际上是左侧的数组追加右边的数组，如果key一样，则以左边的为准。</p><blockquote><blockquote><p>The + operator returns the right-hand array appended to the left-hand array; for keys that exist in both arrays, the elements from the left-hand array will be used, and the matching elements from the right-hand array will be ignored.</p></blockquote></blockquote><p><code>array_merge</code> 是真正的合并，如果key一样，以最后一个为准（没有key的则直接合并）。</p><p>总结：</p><ul><li><code>array_merge</code> 会重写相同的key的值，<code>+</code>不会。</li><li>对于自然数序列的数组（其实就是用<code>array_values</code>处理过的数组）, <code>array_merge()</code>操作追加操作，<code>+</code> 则是合并操作。</li></ul><h2 id="函数式"><a href="#函数式" class="headerlink" title="函数式"></a>函数式</h2><p>array_map<br>array_reduce<br>array_filter</p><h2 id="分割-amp-amp-插入"><a href="#分割-amp-amp-插入" class="headerlink" title="分割 &amp;&amp; 插入"></a>分割 &amp;&amp; 插入</h2><p>array_splice<br>array_splice<br>array_chunk</p><h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><p>sort<br>ksort</p><h2 id="关联数组"><a href="#关联数组" class="headerlink" title="关联数组"></a>关联数组</h2><p>unset</p><p>array_uniqe</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;收集了一些php原始数组函数的使用、注意事项&lt;/p&gt;
&lt;h2 id=&quot;和-array-merge&quot;&gt;&lt;a href=&quot;#和-array-merge&quot; class=&quot;headerlink&quot; title=&quot;+ 和 array_merge&quot;&gt;&lt;/a&gt;+ 和 array_merge
      
    
    </summary>
    
    
  </entry>
  
</feed>
